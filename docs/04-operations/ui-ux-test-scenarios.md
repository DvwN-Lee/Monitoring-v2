Loaded cached credentials.
네, 알겠습니다. Chrome DevTools Protocol(CDP)을 활용한 자동화 테스트에 적합하도록, 제공해주신 프로젝트 정보를 바탕으로 상세한 UI/UX 테스트 시나리오를 작성해 드리겠습니다.

다음은 블로그 서비스와 모니터링 대시보드 UI에 대한 포괄적인 테스트 시나리오입니다.

***

## Chrome DevTools Protocol 기반 UI/UX 자동화 테스트 시나리오

### 1. 블로그 서비스 UI (Blog Service UI)

- **Target URL:** `http://10.0.11.168:31304/blog/`
- **주요 기술:** Python FastAPI (Jinja2 템플릿), JavaScript (Fetch API), Bootstrap

#### 1.1. 핵심 사용자 시나리오 (User Flow)

**시나리오 1: 비로그인 사용자의 게시물 조회**
1.  **[Navigate]** 블로그 메인 페이지 접속
2.  **[Verify]** 페이지 타이틀이 "블로그"인지 확인
3.  **[Verify]** 게시물 목록이 1개 이상 표시되는지 확인
4.  **[Action]** "CI/CD" 카테고리 필터 클릭
5.  **[Verify]** URL이 `?category=CI/CD` 와 같이 변경되고, 해당 카테고리 게시물만 필터링되어 표시되는지 확인
6.  **[Action]** 첫 번째 게시물 제목 클릭
7.  **[Verify]** 게시물 상세 페이지로 이동하고, 해당 게시물의 제목과 내용이 올바르게 표시되는지 확인
8.  **[Action]** 브라우저 '뒤로 가기' 기능 실행
9.  **[Verify]** 이전의 필터링된 게시물 목록 페이지로 돌아오는지 확인
10. **[Action]** 페이지네이션(Pagination)의 '2'번 또는 '다음' 버튼 클릭
11. **[Verify]** 다음 페이지의 게시물 목록이 로드되는지 확인

**시나리오 2: 신규 사용자 회원가입 및 자동 로그인**
1.  **[Navigate]** 블로그 메인 페이지 접속
2.  **[Action]** 네비게이션 바의 '회원가입' 버튼 클릭
3.  **[Verify]** 회원가입 모달 창이 표시되는지 확인
4.  **[Action]** 사용자 이름(`testuser_` + timestamp), 비밀번호(`password123!`) 입력
5.  **[Action]** '가입' 버튼 클릭
6.  **[Verify]** "회원가입이 완료되었습니다." 와 같은 성공 메시지 확인
7.  **[Verify]** 모달이 닫히고, 네비게이션 바에 '로그아웃'과 '새 글 작성' 버튼이 표시되는지 확인 (자동 로그인 검증)

**시나리오 3: 기존 사용자 로그인 후 게시물 작성, 수정, 삭제**
1.  **[Navigate]** 블로그 메인 페이지 접속
2.  **[Action]** 네비게이션 바의 '로그인' 버튼 클릭
3.  **[Action]** 사용자 이름(`testuser`), 비밀번호(`password`) 입력 후 '로그인' 버튼 클릭
4.  **[Verify]** 네비게이션 바에 '로그아웃'과 '새 글 작성' 버튼이 표시되는지 확인
5.  **[Action]** '새 글 작성' 버튼 클릭
6.  **[Verify]** 글 작성 페이지로 이동하는지 확인
7.  **[Action]** 제목("자동화 테스트 게시물"), 내용("이것은 CDP를 통해 작성된 테스트입니다."), 카테고리("Test") 선택 후 '저장' 버튼 클릭
8.  **[Verify]** 메인 페이지로 리디렉션되고, 방금 작성한 게시물이 목록 최상단에 표시되는지 확인
9.  **[Action]** 방금 작성한 게시물의 '수정' 버튼 클릭
10. **[Action]** 제목을 "자동화 테스트 게시물 (수정됨)"으로 변경 후 '저장' 버튼 클릭
11. **[Verify]** 메인 페이지에서 게시물 제목이 수정되었는지 확인
12. **[Action]** 해당 게시물의 '삭제' 버튼 클릭
13. **[Action]** 브라우저의 `confirm()` 대화상자에서 '확인' 클릭
14. **[Verify]** 해당 게시물이 목록에서 사라졌는지 확인

#### 1.2. 테스트 UI 요소 및 상호작용

-   **네비게이션 바:** 로고, 홈, 로그인/로그아웃, 회원가입, 새 글 작성 버튼
-   **게시물 목록 (`.post-item`):** 제목, 작성자, 작성일, 카테고리 태그
-   **카테고리 필터 (`.category-filter`):** 각 카테고리 링크 (인프라, CI/CD 등)
-   **페이지네이션 (`.pagination`):** 이전/다음, 페이지 번호 링크
-   **모달 (`#loginModal`, `#signupModal`):** 입력 필드(username, password), 액션 버튼
-   **글 작성/수정 폼:** 제목/내용 입력 필드, 카테고리 선택 드롭다운, 저장 버튼
-   **게시물 상세:** 제목, 내용, 댓글(구현된 경우)
-   **버튼:** 수정, 삭제 버튼

#### 1.3. 예상 결과 및 검증 포인트

-   **API 호출 검증:** CDP의 `Network` 도메인을 사용하여 각 상호작용 시 예상되는 API 요청(메서드, URL, 페이로드)과 응답(상태 코드 200/201)을 확인.
    -   `GET /blog/api/posts?category=...`
    -   `POST /blog/api/users/signup`
    -   `POST /blog/api/users/login`
    -   `POST /blog/api/posts`
    -   `PUT /blog/api/posts/{id}`
    -   `DELETE /blog/api/posts/{id}`
-   **DOM 상태 검증:** 액션 이후 DOM이 예상대로 변경되었는지 확인. (예: 로그인 후, `#login-button`이 사라지고 `#logout-button`이 나타남)
-   **쿠키/로컬 스토리지 검증:** 로그인 시 `access_token`과 같은 인증 토큰이 저장되는지 확인.

#### 1.4. 성능 및 접근성 고려사항

-   **성능 (Performance):**
    -   `Performance.getMetrics`를 사용하여 LCP(Largest Contentful Paint), CLS(Cumulative Layout Shift) 등 Core Web Vitals 측정.
    -   게시물 100개 이상일 때 페이지네이션 및 필터링 성능 측정. API 응답 시간이 200ms 이내인지 확인.
-   **접근성 (Accessibility):**
    -   CDP의 `Accessibility.getFullAXTree`를 사용하여 접근성 트리 스냅샷 생성.
    -   모든 버튼과 링크에 `aria-label` 또는 명확한 텍스트가 있는지 확인.
    -   `Tab` 키를 이용한 키보드 네비게이션이 논리적 순서로 동작하는지 테스트.

#### 1.5. 에러 케이스 및 엣지 케이스

-   **로그인 실패:** 잘못된 비밀번호 입력 시 "아이디 또는 비밀번호가 올바르지 않습니다." 메시지 표시 확인.
-   **회원가입 실패:** 이미 존재하는 사용자 이름으로 가입 시도 시 "이미 존재하는 사용자입니다." 메시지 확인.
-   **폼 유효성 검사:** 글 작성 시 제목이나 내용을 비워두고 저장 시도 시 "필수 입력 항목입니다."와 같은 경고 확인.
-   **권한 없음:** 로그인하지 않은 상태에서 글 작성 페이지 URL(`.../create`)로 직접 접근 시 로그인 페이지로 리디렉션되는지 확인.
-   **API 서버 오류:** 백엔드 API가 500 에러를 반환할 때, UI가 깨지지 않고 "일시적인 오류가 발생했습니다."와 같은 사용자 친화적 메시지를 표시하는지 확인. (Mocking 필요)
-   **데이터 없음:** 특정 카테고리에 게시물이 없을 경우, "표시할 게시물이 없습니다." 메시지 확인.

---

### 2. 모니터링 대시보드 UI (Dashboard UI)

-   **Target URL:** `http://10.0.11.168:30300` (Grafana) 또는 별도 Dashboard UI URL
-   **주요 기술:** JavaScript (React/Vue 등 SPA 가능성), Chart.js/D3.js, WebSocket

#### 2.1. 핵심 사용자 시나리오 (User Flow)

**시나리오 1: 대시보드 초기 로딩 및 실시간 데이터 확인**
1.  **[Navigate]** 대시보드 페이지 접속
2.  **[Verify]** 페이지가 3초 이내에 로드되고, 모든 차트와 패널의 레이아웃이 깨지지 않는지 확인.
3.  **[Verify]** '서비스별 상태' 패널에 `api-gateway`, `auth-service`, `blog-service` 등이 'Healthy' 또는 녹색 상태로 표시되는지 확인.
4.  **[Verify]** '처리량(RPS)' 및 '응답시간' 차트에 데이터가 렌더링되는지 확인.
5.  **[Wait]** 15초 대기 (Grafana 등 대시보드의 일반적인 refresh 주기).
6.  **[Verify]** 차트 데이터가 자동으로 업데이트되는지 확인 (이전 스냅샷과 비교).
7.  **[Verify]** 'Load Balancer 로그' 패널에 새로운 로그가 스트리밍되는지 확인.

**시나리오 2: 차트 상호작용**
1.  **[Action]** '응답시간' 차트 위로 마우스 커서 이동.
2.  **[Verify]** 특정 시간대의 p99, p95, p50 응답시간을 보여주는 툴팁(Tooltip)이 표시되는지 확인.
3.  **[Action]** (시간 범위 선택 기능이 있다면) 시간 범위를 '지난 1시간'에서 '지난 6시간'으로 변경.
4.  **[Verify]** 모든 차트가 새로운 시간 범위에 맞춰 데이터와 X축을 다시 렌더링하는지 확인.

#### 2.2. 테스트 UI 요소 및 상호작용

-   **패널/위젯:** 서비스 상태, RPS, 응답시간, 알람, 로그 뷰어 등 각 대시보드 구성 요소.
-   **차트 (`<canvas>` 또는 `<svg>`):** 라인/바 차트의 데이터 포인트.
-   **툴팁:** 차트 호버 시 나타나는 정보 창.
-   **시간 범위 선택기:** '지난 5분', '지난 1시간' 등.
-   **상태 표시기:** 서비스별 상태를 나타내는 아이콘 또는 텍스트 (예: 녹색 점).

#### 2.3. 예상 결과 및 검증 포인트

-   **데이터 정확성:** Prometheus/Loki에서 직접 쿼리한 결과와 대시보드에 표시되는 값이 일치하는지 비교. (자동화 시, 특정 시점의 API 응답을 스냅샷으로 저장 후 비교)
-   **WebSocket 연결:** `Network` 탭에서 WebSocket 연결이 수립되고 데이터가 주기적으로 수신되는지 확인.
-   **동적 업데이트:** `requestAnimationFrame` 또는 주기적인 `fetch` 호출을 통해 DOM이 업데이트되는 것을 감지.

#### 1.4. 성능 및 접근성 고려사항

-   **성능:**
    -   장시간(예: 1시간) 대시보드를 열어 두었을 때 메모리 누수(Memory Leak)가 없는지 `Performance.getMetrics`로 확인.
    -   데이터 포인트가 수천 개 이상일 때도 UI가 버벅이지 않고 부드럽게 상호작용되는지 확인.
-   **접근성:**
    -   차트 데이터는 시각 정보 외에 테이블 형태로도 제공되는지 확인.
    -   상태를 나타내는 색상(빨강/녹색) 외에 텍스트나 아이콘으로도 상태를 명시하는지 확인 (색맹 사용자 고려).

#### 1.5. 에러 케이스 및 엣지 케이스

-   **데이터 소스 연결 실패:** Grafana가 Prometheus/Loki에 연결할 수 없을 때, 각 패널에 "Data source error"와 같은 명확한 오류 메시지가 표시되는지 확인.
-   **데이터 없음 (No Data):** 특정 기간에 메트릭이 없을 경우, 차트에 "No data"라고 표시되는지 확인.
-   **알람 발생:** Prometheus Alertmanager에서 의도적으로 알람을 발생시킨 후, 대시보드의 '알람' 패널에 해당 알람이 빨간색으로 표시되는지 확인.
-   **급격한 로그 증가:** Load Balancer에 초당 수백 개의 로그가 발생할 때, 로그 뷰어가 UI를 멈추게 하지 않고 정상적으로 스크롤 및 렌더링되는지 확인.
