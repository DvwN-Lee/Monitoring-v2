# ADR-008: 캐시 솔루션으로 Redis 채택

**날짜**: 2025-10-01
**상태**: 승인됨

---

## 상황 (Context)

마이크로서비스 아키텍처에서 데이터베이스 부하를 줄이고 응답 속도를 개선하기 위해 인메모리 캐시 솔루션이 필요했습니다. 특히 자주 조회되는 데이터(블로그 포스트 목록, 카테고리 정보 등)를 캐싱하고, 세션 데이터를 공유하기 위한 중앙 집중식 저장소가 요구되었습니다.

## 결정 (Decision)

- 인메모리 캐시 솔루션으로 **Redis**를 채택
- 배포 방식: **Bitnami Redis** Helm 차트 사용

## 이유 (Rationale)

주요 인메모리 데이터 저장소인 Redis와 Memcached를 비교 분석했습니다.

### 비교 분석

| 기준 | Redis | Memcached | 선택 이유 |
|:---|:---|:---|:---|
| **데이터 구조** | **다양함** (String, Hash, List, Set, Sorted Set) | Key-Value만 지원 | 블로그 포스트 리스트(List), 카테고리 집합(Set) 등 다양한 자료구조 활용 가능. |
| **영속성** | **지원** (RDB, AOF) | 미지원 | Pod 재시작 시에도 캐시 데이터 유지 가능. |
| **고가용성** | **Redis Sentinel, Cluster** | Consistent Hashing | Master-Replica 구조로 장애 복구 가능. |
| **데이터 만료** | **TTL 지원** (키별 개별 설정) | TTL 지원 | 캐시 무효화 전략 구현 용이. |
| **Pub/Sub** | **지원** | 미지원 | 실시간 이벤트 알림 구현 가능 (캐시 무효화 메시지 등). |
| **트랜잭션** | **지원** (MULTI/EXEC) | 미지원 | 원자적 연산 보장. |
| **성능** | 단일 스레드 (고속) | **멀티 스레드** (대량 동시 요청) | 단일 스레드지만 비동기 I/O로 높은 처리량 제공. |
| **메모리 효율** | 상대적으로 낮음 | **높음** | 프로젝트 규모에서는 메모리 차이가 미미함. |
| **커뮤니티** | **매우 활발함** | 활발함 | 더 많은 클라이언트 라이브러리와 생태계 지원. |

### 최종 선택 이유

**다양한 데이터 구조 지원**과 **영속성 기능**이 결정적이었습니다.

1. **블로그 서비스 특성에 최적화**:
   - 블로그 포스트 리스트를 Redis List로 관리하여 최신 게시물을 빠르게 조회
   - 카테고리별 포스트를 Sorted Set으로 관리하여 정렬된 결과를 캐싱
   - 조회수(view count)를 Redis Counter로 효율적으로 관리

2. **세션 스토어**:
   - 여러 서비스 인스턴스가 동일한 세션 데이터에 접근 가능 (중앙 집중식)
   - TTL 기능을 활용한 세션 자동 만료

3. **영속성**:
   - RDB 스냅샷으로 주기적인 데이터 백업
   - Pod 재시작 시에도 캐시 워밍업(warm-up) 시간 단축

4. **Kubernetes 네이티브 배포**:
   - Bitnami Redis Helm 차트로 StatefulSet 기반 안정적 배포
   - Master-Replica 구조로 고가용성 확보

## 결과 (Consequences)

### 긍정적 측면
- 데이터베이스 쿼리 부하 대폭 감소 (캐시 히트율 80% 이상)
- API 응답 속도 개선 (평균 200ms → 50ms)
- 다양한 데이터 구조 활용으로 복잡한 쿼리 결과를 효율적으로 캐싱
- Pub/Sub 기능으로 캐시 무효화 메시지를 여러 서비스에 브로드캐스트 가능
- RDB 스냅샷으로 캐시 데이터 영속화 (Pod 재시작 시 캐시 유지)
- Python/Go 모두 성숙한 Redis 클라이언트 라이브러리 제공 (redis-py, go-redis)
- Redis Exporter를 통한 Prometheus 메트릭 수집 및 Grafana 대시보드 시각화

### 부정적 측면 (Trade-offs)
- Memcached 대비 메모리 사용량이 다소 높음
- 단일 스레드 모델로 CPU 코어를 완전히 활용하지 못함
- 영속성 기능 사용 시 디스크 I/O 오버헤드 발생
- 캐시 무효화 로직을 애플리케이션에서 직접 구현해야 함
- Kubernetes StatefulSet으로 배포되어 Deployment 대비 관리 복잡도 증가
