# ADR-002: 데이터베이스로 PostgreSQL 채택

**날짜**: 2025-09-30

---

## 상황 (Context)

프로젝트 v1.0에서는 `user-service`와 `blog-service`가 각각의 데이터를 **SQLite** 파일에 저장했습니다. 로컬 개발 환경에서는 간편했지만, `replicas`를 2 이상으로 설정하여 수평으로 확장하는 쿠버네티스 환경에서는 치명적인 한계를 드러냅니다. 각 Pod가 별도의 파일 시스템을 가지므로, 데이터가 분리되고 정합성이 깨지는 문제가 발생합니다.

## 결정 (Decision)

- 파일 기반 데이터베이스인 SQLite를 폐기하고, 네트워크 기반의 관계형 데이터베이스인 **PostgreSQL**을 도입
- 초기에는 Kubernetes의 `StatefulSet`과 `PersistentVolume`을 이용해 직접 배포하고, 최종적으로는 관리형 서비스(AWS RDS)로 전환하는 것을 목표로 함

## 이유 (Rationale)

### SQLite의 문제점
1.  **동시 쓰기 제한**: 파일 잠금(locking) 메커니즘으로 인해 여러 Pod에서의 동시 쓰기 작업이 불가능하거나 매우 비효율적입니다.
2.  **수평 확장 불가**: `ReadWriteOnce` PVC 모드에서는 단 하나의 Pod만 볼륨에 쓸 수 있어 `replicas`를 늘릴 수 없습니다.
3.  **데이터 공유 불가**: 각 Pod가 독립적인 DB 파일을 가지게 되어 서비스 전체의 데이터가 파편화(Fragmentation)됩니다.

### PostgreSQL 채택 이유

| 기준 | PostgreSQL (StatefulSet) | SQLite (PVC) | 선택 이유 |
|:---|:---|:---|:---|
| **분산 환경 적합성** | **네트워크 기반, 동시 접근 가능** | 파일 기반, 단일 접근 | **[핵심]** 여러 Pod에서 동시에 안전하게 데이터를 읽고 쓸 수 있어 MSA에 필수적임. |
| **수평 확장성 (HPA)** | **가능** | 불가능 | 서비스에 부하가 발생했을 때 Pod를 자동으로 늘려 대응할 수 있음. |
| **데이터 정합성** | **보장 (ACID)** | 보장 불가 (분산 환경에서) | 모든 서비스가 동일한 중앙 데이터 소스를 참조하여 데이터 일관성을 유지함. |
| **기능 및 생태계** | 풍부한 기능, 강력한 ORM 지원 | 기능 제한적 | 복잡한 쿼리, 트랜잭션, 고급 데이터 타입을 지원하며 SQLAlchemy, GORM 등과 호환성이 좋음. |

### 최종 선택 이유

마이크로서비스 아키텍처의 핵심 이점인 **'독립적인 확장성'**을 확보하기 위해 PostgreSQL 채택이 필요해보였습니다. SQLite를 유지하는 것은 MSA의 근본적인 목적에 위배된다고 판단했습니다. 또한, `StatefulSet`을 통해 직접 배포하는 경험은 쿠버네티스의 스토리지 관리 측면에서도 좋을 것 같았습니다.

## 결과 (Consequences)

### 긍정적 측면
-   서비스의 수평 확장이 가능해져 트래픽 증가에 유연하게 대응할 수 있게 됨.
-   모든 서비스가 중앙 데이터베이스를 바라보게 되어 데이터 정합성이 보장됨.
-   Kubernetes의 `StatefulSet`, `PersistentVolume` 등 영속적 데이터 관리 패턴을 학습하고 적용할 수 있음.

### 부정적 측면 (Trade-offs)
-   SQLite에 비해 초기 설정 및 관리가 복잡하다. (DB 사용자, 권한, 네트워크 설정 등)
-   별도의 데이터베이스 서버를 운영해야 하므로 시스템의 복잡도가 증가한다.